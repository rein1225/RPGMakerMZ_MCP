import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { CallToolRequestSchema, ListToolsRequestSchema, ListResourcesRequestSchema, ReadResourceRequestSchema } from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";
import fs from "fs/promises";
import path from "path";
import { spawn } from "child_process";
import robot from "robotjs";
import screenshot from "screenshot-desktop";
import { fileURLToPath } from "url";
import puppeteer from "puppeteer";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const server = new Server(
  {
    name: "rpg-maker-mz-mcp",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
      resources: {},
    },
  }
);

// Helper to validate project path
async function validateProjectPath(projectPath) {
  try {
    const stats = await fs.stat(projectPath);
    if (!stats.isDirectory()) {
      throw new Error(`Path is not a directory: ${projectPath}`);
    }
    // Check for game.rmmzproject to confirm it's an MZ project
    const projectFile = path.join(projectPath, "game.rmmzproject");
    try {
      await fs.access(projectFile);
    } catch {
      throw new Error(`Not a valid RPG Maker MZ project (game.rmmzproject not found): ${projectPath}`);
    }
  } catch (error) {
    throw new Error(`Invalid project path: ${error.message}`);
  }
}

// Helper for recursive file listing
async function getFilesRecursively(dir) {
  const dirents = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(dirents.map((dirent) => {
    const res = path.join(dir, dirent.name);
    return dirent.isDirectory() ? getFilesRecursively(res) : res;
  }));
  return Array.prototype.concat(...files);
}

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

server.setRequestHandler(ListResourcesRequestSchema, async () => {
  return {
    resources: [
      {
        uri: "mz://docs/event_commands",
        name: "RPG Maker MZ Event Command Reference",
        description: "Reference manual for MZ event commands with code to parameters mapping",
        mimeType: "application/json"
      }
    ]
  };
});

server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
  const { uri } = request.params;

  if (uri === "mz://docs/event_commands") {
    try {
      const refPath = path.join(__dirname, "resources", "event_commands.json");
      const content = await fs.readFile(refPath, "utf-8");
      return {
        contents: [
          {
            uri: uri,
            mimeType: "application/json",
            text: content
          }
        ]
      };
    } catch (e) {
      throw new Error(`Failed to read event commands reference: ${e.message}`);
    }
  }

  throw new Error(`Unknown resource: ${uri}`);
});

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "get_project_info",
        description: "Get basic information about the RPG Maker MZ project from System.json",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
          },
          required: ["projectPath"],
        },
      },
      {
        name: "list_data_files",
        description: "List all JSON data files in the project's data directory",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
          },
          required: ["projectPath"],
        },
      },
      {
        name: "read_data_file",
        description: "Read the content of a specific data file (e.g., Actors.json)",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
            filename: {
              type: "string",
              description: "Name of the file to read (e.g., 'Actors.json')",
            },
          },
          required: ["projectPath", "filename"],
        },
      },
      {
        name: "write_data_file",
        description: "Write content to a specific data file (e.g., Actors.json)",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
            filename: {
              type: "string",
              description: "Name of the file to write (e.g., 'Actors.json')",
            },
            content: {
              type: "string",
              description: "The JSON content to write to the file",
            },
          },
          required: ["projectPath", "filename", "content"],
        },
      },
      {
        name: "write_plugin_code",
        description: "Write a JavaScript plugin file to the js/plugins directory",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
            filename: {
              type: "string",
              description: "Name of the plugin file (e.g., 'MyPlugin.js')",
            },
            code: {
              type: "string",
              description: "The JavaScript code for the plugin",
            },
          },
          required: ["projectPath", "filename", "code"],
        },
      },
      {
        name: "get_plugins_config",
        description: "Read the current plugin configuration from js/plugins.js",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
          },
          required: ["projectPath"],
        },
      },
      {
        name: "update_plugins_config",
        description: "Update the plugin configuration in js/plugins.js",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
            plugins: {
              type: "array",
              description: "List of plugin objects to save",
              items: {
                type: "object",
                properties: {
                  name: { type: "string" },
                  status: { type: "boolean" },
                  description: { type: "string" },
                  parameters: { type: "object" }
                },
                required: ["name", "status", "description", "parameters"]
              }
            },
          },
          required: ["projectPath", "plugins"],
        },
      },
      {
        name: "list_assets",
        description: "List files in img and audio directories",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
            assetType: {
              type: "string",
              description: "Type of asset to list (img, audio, or all)",
              enum: ["img", "audio", "all"]
            }
          },
          required: ["projectPath"],
        },
      },
      {
        name: "search_events",
        description: "Search for text or codes in Map events and Common events",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
            query: {
              type: "string",
              description: "Text or number to search for",
            },
          },
          required: ["projectPath", "query"],
        },
      },
      {
        name: "run_playtest",
        description: "Launch the game (Game.exe) and take a screenshot after a delay. Can optionally close the game automatically.",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
            duration: {
              type: "number",
              description: "Wait duration in milliseconds before taking screenshot (default: 5000)",
            },
            autoClose: {
              type: "boolean",
              description: "If true, terminates the game process after taking the screenshot. Useful for batch testing. (default: false)",
            },
            startNewGame: {
              type: "boolean",
              description: "If true, automatically starts a new game (skips title screen). Default: false",
            },
          },
          required: ["projectPath"],
        },
      },
      {
        name: "get_event_page",
        description: "Get the event command list for a specific event page. Returns readable descriptions for common commands.",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
            mapId: {
              type: "number",
              description: "Target map ID",
            },
            eventId: {
              type: "number",
              description: "Target event ID",
            },
            pageIndex: {
              type: "number",
              description: "Page index (0-based)",
            },
          },
          required: ["projectPath", "mapId", "eventId", "pageIndex"],
        },
      },
      {
        name: "add_dialogue",
        description: "Add a dialogue (Show Text) event to a map event. AI-friendly abstraction that handles MZ's internal event command structure.",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
            mapId: {
              type: "number",
              description: "Target map ID (e.g., 1 for Map001.json)",
            },
            eventId: {
              type: "number",
              description: "Target event ID within the map",
            },
            pageIndex: {
              type: "number",
              description: "Page index (0-based)",
            },
            insertPosition: {
              type: "number",
              description: "Insert position in the event list (-1 for end, before code:0)",
            },
            text: {
              type: "string",
              description: "Dialogue text. Use newline character for line breaks.",
            },
            face: {
              type: "string",
              description: "Face graphic filename (without extension). Leave empty for no face.",
            },
            faceIndex: {
              type: "number",
              description: "Face graphic index (0-7). Default: 0",
            },
            background: {
              type: "number",
              description: "Background type: 0=Window, 1=Dim, 2=Transparent. Default: 0",
            },
            position: {
              type: "number",
              description: "Position: 0=Top, 1=Middle, 2=Bottom. Default: 2",
            },
          },
          required: ["projectPath", "mapId", "eventId", "pageIndex", "insertPosition", "text"],
        },
      },
      {
        name: "add_conditional_branch",
        description: "Add a Conditional Branch structure (If-Else-End) to a map event.",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: {
              type: "string",
              description: "Absolute path to the RPG Maker MZ project folder",
            },
            mapId: {
              type: "number",
              description: "Target map ID",
            },
            eventId: {
              type: "number",
              description: "Target event ID",
            },
            pageIndex: {
              type: "number",
              description: "Page index (0-based)",
            },
            insertPosition: {
              type: "number",
              description: "Insert position (-1 for end)",
            },
            condition: {
              type: "object",
              description: "Condition parameters",
              properties: {
                code: { type: "number", description: "0:Switch, 1:Variable, etc." },
                dataA: { type: "number", description: "Switch ID, Variable ID, etc." },
                operation: { type: "number", description: "0:Equal, 1:Greater, etc." },
                dataB: { type: "number", description: "Constant, Variable ID, etc." },
                class: { type: "number", description: "Extension data (default: 0)" }
              },
              required: ["code", "dataA", "operation", "dataB"]
            },
            includeElse: {
              type: "boolean",
              description: "Include 'Else' branch? (default: true)",
            },
          },
          required: ["projectPath", "mapId", "eventId", "pageIndex", "insertPosition", "condition"],
        },
      },
      {
        name: "delete_event_command",
        description: "Delete a specific command from an event page.",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: { type: "string" },
            mapId: { type: "number" },
            eventId: { type: "number" },
            pageIndex: { type: "number" },
            commandIndex: { type: "number", description: "Index of the command to delete (0-based)" },
          },
          required: ["projectPath", "mapId", "eventId", "pageIndex", "commandIndex"],
        },
      },
      {
        name: "update_event_command",
        description: "Update a specific command in an event page.",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: { type: "string" },
            mapId: { type: "number" },
            eventId: { type: "number" },
            pageIndex: { type: "number" },
            commandIndex: { type: "number", description: "Index of the command to update (0-based)" },
            newCommand: {
              type: "object",
              description: "New command object",
              properties: {
                code: { type: "number" },
                indent: { type: "number" },
                parameters: { type: "array", items: { type: ["string", "number", "object", "boolean"] } },
              },
              required: ["code", "parameters"],
            },
          },
          required: ["projectPath", "mapId", "eventId", "pageIndex", "commandIndex", "newCommand"],
        },
      },
      {
        name: "add_actor",
        description: "Add a new actor to the database.",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: { type: "string" },
            name: { type: "string" },
            classId: { type: "number", default: 1 },
            initialLevel: { type: "number", default: 1 },
            maxLevel: { type: "number", default: 99 },
          },
          required: ["projectPath", "name"],
        },
      },
      {
        name: "add_item",
        description: "Add a new item to the database.",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: { type: "string" },
            name: { type: "string" },
            price: { type: "number", default: 0 },
            consumable: { type: "boolean", default: true },
            scope: { type: "number", default: 7, description: "0:None, 1:One Enemy, 7:One Ally, etc." },
            occasion: { type: "number", default: 0, description: "0:Always, 1:Battle, 2:Menu, 3:Never" },
          },
          required: ["projectPath", "name"],
        },
      },
      {
        name: "add_skill",
        description: "Add a new skill to the database.",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: { type: "string" },
            name: { type: "string" },
            mpCost: { type: "number", default: 0 },
            tpCost: { type: "number", default: 0 },
            scope: { type: "number", default: 1 },
            occasion: { type: "number", default: 1 },
          },
          required: ["projectPath", "name"],
        },
      },
      {
        name: "draw_map_tile",
        description: "Draw a tile at specific coordinates on a map.",
        inputSchema: {
          type: "object",
          properties: {
            projectPath: { type: "string" },
            mapId: { type: "number" },
            x: { type: "number" },
            y: { type: "number" },
            layer: { type: "number", description: "0-3: Map Layers, 4: Shadow, 5: Region" },
            tileId: { type: "number" },
          },
          required: ["projectPath", "mapId", "x", "y", "layer", "tileId"],
        },
      },
      {
        name: "inspect_game_state",
        description: "Inspect game variables and switches via Puppeteer. Requires game running with --remote-debugging-port.",
        inputSchema: {
          type: "object",
          properties: {
            port: { type: "number", default: 9222, description: "Remote debugging port" },
            script: { type: "string", description: "JavaScript code to evaluate (e.g. '$gameVariables.value(1)')" },
          },
          required: ["script"],
        },
      },
    ],
  };
});

// Helper to load map data
async function loadMapData(projectPath, mapId) {
  const mapIdPadded = String(mapId).padStart(3, "0");
  const mapFilePath = path.join(projectPath, "data", `Map${mapIdPadded}.json`);
  try {
    const mapContent = await fs.readFile(mapFilePath, "utf-8");
    return JSON.parse(mapContent);
  } catch (e) {
    throw new Error(`Failed to read map file: ${e.message}`);
  }
}

// Helper to save map data
async function saveMapData(projectPath, mapId, mapData) {
  const mapIdPadded = String(mapId).padStart(3, "0");
  const mapFilePath = path.join(projectPath, "data", `Map${mapIdPadded}.json`);
  await fs.writeFile(mapFilePath, JSON.stringify(mapData, null, 2), "utf-8");
}

// Helper to get event page list
function getEventPageList(mapData, eventId, pageIndex) {
  if (!mapData.events[eventId]) {
    throw new Error(`Event ${eventId} not found in Map`);
  }
  const event = mapData.events[eventId];
  if (!event.pages[pageIndex]) {
    throw new Error(`Page ${pageIndex} not found in Event ${eventId}`);
  }
  return event.pages[pageIndex].list;
}



// Helper to annotate commands
const annotateCommand = (cmd) => {
  let description = "";
  switch (cmd.code) {
    case 101: description = `Show Text: Face=${cmd.parameters[0]}(${cmd.parameters[1]})`; break;
    case 401: description = `Text: ${cmd.parameters[0]}`; break;
    case 102: description = `Show Choices: ${JSON.stringify(cmd.parameters[0])}`; break;
    case 402: description = `When: [${cmd.parameters[1]}]`; break;
    case 403: description = `When Cancel`; break;
    case 121: description = `Control Switches: ${cmd.parameters[0]}-${cmd.parameters[1]} = ${cmd.parameters[2] === 0 ? 'ON' : 'OFF'}`; break;
    case 122: description = `Control Variables: ${cmd.parameters[0]}-${cmd.parameters[1]} = ${cmd.parameters[3]}`; break;
    case 231: description = `Show Picture: #${cmd.parameters[0]} ${cmd.parameters[1]}`; break;
    case 201: description = `Transfer Player: Map ${cmd.parameters[1]} (${cmd.parameters[2]},${cmd.parameters[3]})`; break;
    case 112: description = `Loop`; break;
    case 413: description = `Repeat Above`; break;
    case 113: description = `Break Loop`; break;
    case 111: description = `Conditional Branch: Code=${cmd.parameters[0]} A=${cmd.parameters[1]} Op=${cmd.parameters[2]} B=${cmd.parameters[3]}`; break;
    case 411: description = `Else`; break;
    case 412: description = `Branch End`; break;
  }
  return {
    ...cmd,
    _description: description || undefined
  };
};

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  console.error("Processing tool:", name);

  try {
    if (name === "get_project_info") {
      const { projectPath } = args;
      await validateProjectPath(projectPath);

      const systemPath = path.join(projectPath, "data", "System.json");
      const content = await fs.readFile(systemPath, "utf-8");
      const systemData = JSON.parse(content);

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              gameTitle: systemData.gameTitle,
              versionId: systemData.versionId,
              locale: systemData.locale,
              currencyUnit: systemData.currencyUnit,
            }, null, 2),
          },
        ],
      };
    }

    if (name === "list_data_files") {
      const { projectPath } = args;
      await validateProjectPath(projectPath);

      const dataDir = path.join(projectPath, "data");
      const files = await fs.readdir(dataDir);
      const jsonFiles = files.filter(f => f.endsWith(".json"));

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(jsonFiles, null, 2),
          },
        ],
      };
    }

    if (name === "read_data_file") {
      const { projectPath, filename } = args;
      await validateProjectPath(projectPath);

      if (!filename.endsWith(".json")) {
        throw new Error("Only .json files can be read");
      }

      const filePath = path.join(projectPath, "data", filename);
      const content = await fs.readFile(filePath, "utf-8");

      return {
        content: [
          {
            type: "text",
            text: content,
          },
        ],
      };
    }

    if (name === "write_data_file") {
      const { projectPath, filename, content } = args;
      await validateProjectPath(projectPath);

      if (!filename.endsWith(".json")) {
        throw new Error("Only .json files can be written");
      }

      // Validate that content is valid JSON
      try {
        JSON.parse(content);
      } catch (e) {
        throw new Error("Content must be valid JSON string");
      }

      const filePath = path.join(projectPath, "data", filename);
      await fs.writeFile(filePath, content, "utf-8");

      return {
        content: [
          {
            type: "text",
            text: `Successfully wrote to ${filename}`,
          },
        ],
      };
    }

    if (name === "write_plugin_code") {
      const { projectPath, filename, code } = args;
      await validateProjectPath(projectPath);

      if (!filename.endsWith(".js")) {
        throw new Error("Plugin filename must end with .js");
      }

      const pluginsDir = path.join(projectPath, "js", "plugins");
      // Ensure plugins directory exists
      try {
        await fs.mkdir(pluginsDir, { recursive: true });
      } catch (e) {
        // Ignore if exists
      }

      const filePath = path.join(pluginsDir, filename);
      await fs.writeFile(filePath, code, "utf-8");

      return {
        content: [
          {
            type: "text",
            text: `Successfully wrote plugin code to ${filename}`,
          },
        ],
      };
    }

    if (name === "get_plugins_config") {
      const { projectPath } = args;
      await validateProjectPath(projectPath);

      const pluginsConfigPath = path.join(projectPath, "js", "plugins.js");

      try {
        const content = await fs.readFile(pluginsConfigPath, "utf-8");
        const match = content.match(/var\s+\$plugins\s*=\s*(\[[\s\S]*?\])\s*;/);
        if (!match) {
          throw new Error("Could not parse plugins.js format");
        }
        const pluginsJson = match[1];
        JSON.parse(pluginsJson);

        return {
          content: [
            {
              type: "text",
              text: pluginsJson,
            },
          ],
        };
      } catch (error) {
        if (error.code === 'ENOENT') {
          return {
            content: [
              {
                type: "text",
                text: "[]",
              },
            ],
          };
        }
        throw error;
      }
    }

    if (name === "update_plugins_config") {
      const { projectPath, plugins } = args;
      await validateProjectPath(projectPath);

      const pluginsConfigPath = path.join(projectPath, "js", "plugins.js");
      const content = `// Generated by RPG Maker.
// Do not edit this file directly.
var $plugins =
${JSON.stringify(plugins, null, 2)};
`;

      await fs.writeFile(pluginsConfigPath, content, "utf-8");

      return {
        content: [
          {
            type: "text",
            text: "Successfully updated plugins.js",
          },
        ],
      };
    }

    if (name === "list_assets") {
      const { projectPath, assetType = "all" } = args;
      await validateProjectPath(projectPath);

      const results = {};

      if (assetType === "img" || assetType === "all") {
        const imgDir = path.join(projectPath, "img");
        try {
          const files = await getFilesRecursively(imgDir);
          results.img = files.map(f => path.relative(projectPath, f).replace(/\\/g, "/"));
        } catch (e) {
          results.img = [`Error reading img directory: ${e.message}`];
        }
      }

      if (assetType === "audio" || assetType === "all") {
        const audioDir = path.join(projectPath, "audio");
        try {
          const files = await getFilesRecursively(audioDir);
          results.audio = files.map(f => path.relative(projectPath, f).replace(/\\/g, "/"));
        } catch (e) {
          results.audio = [`Error reading audio directory: ${e.message}`];
        }
      }

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(results, null, 2),
          },
        ],
      };
    }

    if (name === "search_events") {
      const { projectPath, query } = args;
      await validateProjectPath(projectPath);

      const matches = [];
      const dataDir = path.join(projectPath, "data");

      const searchInList = (list, sourceName) => {
        if (!list) return;
        list.forEach((ev) => {
          if (!ev) return;
          const eventName = ev.name || `Event ${ev.id}`;
          if (ev.pages) {
            ev.pages.forEach((page, pageIndex) => {
              if (page.list) {
                page.list.forEach((cmd, cmdIndex) => {
                  const paramStr = JSON.stringify(cmd.parameters);
                  const codeStr = cmd.code.toString();
                  if (paramStr.includes(query) || (query === codeStr)) {
                    matches.push({
                      source: sourceName,
                      event: eventName,
                      eventId: ev.id,
                      page: pageIndex + 1,
                      line: cmdIndex + 1,
                      code: cmd.code,
                      parameters: cmd.parameters
                    });
                  }
                });
              }
            });
          }
        });
      };

      try {
        const commonEventsPath = path.join(dataDir, "CommonEvents.json");
        const commonEvents = JSON.parse(await fs.readFile(commonEventsPath, "utf-8"));
        searchInList(commonEvents, "CommonEvents");
      } catch (e) { }

      try {
        const mapInfosPath = path.join(dataDir, "MapInfos.json");
        const mapInfos = JSON.parse(await fs.readFile(mapInfosPath, "utf-8"));
        for (const mapInfo of mapInfos) {
          if (!mapInfo) continue;
          const mapId = mapInfo.id.toString().padStart(3, "0");
          const mapFilename = `Map${mapId}.json`;
          const mapPath = path.join(dataDir, mapFilename);
          try {
            const mapData = JSON.parse(await fs.readFile(mapPath, "utf-8"));
            searchInList(mapData.events, `Map ${mapInfo.id}: ${mapInfo.name}`);
          } catch (e) { }
        }
      } catch (e) { }

      return {
        content: [{ type: "text", text: JSON.stringify(matches, null, 2) }],
      };
    }

    if (name === "run_playtest") {
      const { projectPath, duration = 5000, autoClose = false, debugPort = 9222, startNewGame = false } = args;
      await validateProjectPath(projectPath);

      const gameExePath = path.join(projectPath, "Game.exe");
      try {
        await fs.access(gameExePath);
      } catch {
        throw new Error(`Game.exe not found at ${gameExePath}. Please deploy the game or provide correct path.`);
      }

      const debugLogPath = path.join(__dirname, "debug_log.txt");
      await fs.appendFile(debugLogPath, `Launching game: ${gameExePath} with remote debugging on port ${debugPort}\\n`);
      console.error(`Launching game: ${gameExePath} with remote debugging on port ${debugPort}`);

      const spawnArgs = [`--remote-debugging-port=${debugPort}`];
      const gameProcess = spawn(gameExePath, spawnArgs, { detached: true, stdio: 'ignore' });
      gameProcess.unref();

      let result = { content: [] };
      let browser;
      let capturedViaPuppeteer = false;
      const startTime = Date.now();
      const maxWaitTime = Math.max(duration + 10000, 20000);

      try {
        let connected = false;
        while (Date.now() - startTime < maxWaitTime) {
          try {
            browser = await puppeteer.connect({ browserURL: `http://127.0.0.1:${debugPort}`, defaultViewport: null });
            connected = true;
            await fs.appendFile(debugLogPath, "Puppeteer connected successfully.\\n");
            break;
          } catch (e) {
            await sleep(1000);
          }
        }

        if (connected && browser) {
          const pages = await browser.pages();
          const page = pages[0];
          if (page) {
            try {
              await page.waitForSelector('#gameCanvas', { timeout: duration });
              await fs.appendFile(debugLogPath, "Found #gameCanvas.\\n");

              if (startNewGame) {
                await fs.appendFile(debugLogPath, "Attempting to start new game...\\n");
                try {
                  await page.waitForFunction(() => {
                    return window.SceneManager && window.SceneManager._scene && window.SceneManager._scene.constructor.name === 'Scene_Title';
                  }, { timeout: 10000 });
                  await fs.appendFile(debugLogPath, "Scene_Title detected.\\n");
                  await page.evaluate(() => { DataManager.setupNewGame(); SceneManager.goto(Scene_Map); });
                  await fs.appendFile(debugLogPath, "New Game command sent.\\n");
                } catch (e) {
                  await fs.appendFile(debugLogPath, `Failed to start new game: ${e.message}\\n`);
                }
              }

              const remainingTime = Math.max(2000, duration - (Date.now() - startTime));
              try {
                await page.waitForFunction((targetScene) => {
                  if (!window.SceneManager || !window.SceneManager._scene) return false;
                  const sceneName = window.SceneManager._scene.constructor.name;
                  if (sceneName === 'Scene_Boot') return false;
                  if (targetScene && sceneName !== targetScene) return false;
                  return true;
                }, { timeout: remainingTime }, startNewGame ? 'Scene_Map' : null);
                await fs.appendFile(debugLogPath, "Scene ready check passed.\\n");
              } catch (e) {
                await fs.appendFile(debugLogPath, "Scene ready check timed out.\\n");
              }

              await sleep(1000);

              capturedViaPuppeteer = true;
              await fs.appendFile(debugLogPath, "Screenshot taken via page.screenshot.\\n");
            }
            } catch (e) {
            await fs.appendFile(debugLogPath, `Puppeteer operation failed: ${e.message}\\n`);
          }
        }
      } else {
        await fs.appendFile(debugLogPath, "Puppeteer failed to connect.\\n");
      }
    } catch (e) {
      await fs.appendFile(debugLogPath, `Puppeteer connection logic error: ${e.message}\\n`);
    } finally {
      if (browser) await browser.disconnect();
    }

    if (!capturedViaPuppeteer) {
      console.error("Falling back to desktop screenshot");
      const elapsed = Date.now() - startTime;
      if (elapsed < duration) await sleep(duration - elapsed);
      try {
        const imgBuffer = await screenshot({ format: 'png' });
        const base64Img = imgBuffer.toString('base64');
        result.content.push({ type: "image/png", data: base64Img });
        result.content.push({ type: "text", text: "Game launched and screenshot taken (Desktop Fallback)." });
      } catch (e) {
        result.content.push({ type: "text", text: `Game launched but failed to take screenshot: ${e.message}` });
        result.isError = true;
      }
    }

    if (autoClose) {
      try {
        if (process.platform === 'win32') {
          spawn("taskkill", ["/pid", gameProcess.pid, "/f", "/t"]);
          result.content.push({ type: "text", text: "Game process terminated (autoClose: true)." });
        } else {
          gameProcess.kill();
          result.content.push({ type: "text", text: "Game process kill signal sent." });
        }
      } catch (e) {
        result.content.push({ type: "text", text: `Failed to close game process: ${e.message}` });
      }
    }
    return result;
  }

if (name === "get_event_page") {
    const { projectPath, mapId, eventId, pageIndex } = args;
    await validateProjectPath(projectPath);
    const mapData = await loadMapData(projectPath, mapId);
    const list = getEventPageList(mapData, eventId, pageIndex);
    const annotatedList = list.map(annotateCommand);
    return { content: [{ type: "text", text: JSON.stringify(annotatedList, null, 2) }] };
  }

  if (name === "add_dialogue") {
    const { projectPath, mapId, eventId, pageIndex, insertPosition, text, face = "", faceIndex = 0, background = 0, position = 2 } = args;
    await validateProjectPath(projectPath);
    const mapData = await loadMapData(projectPath, mapId);
    const list = getEventPageList(mapData, eventId, pageIndex);
    const pos = insertPosition === -1 ? list.length - 1 : insertPosition;
    const cmds = [];
    cmds.push({ code: 101, indent: 0, parameters: [face, faceIndex, background, position] });
    const lines = text.split('\n');
    lines.forEach(line => { cmds.push({ code: 401, indent: 0, parameters: [line] }); });
    list.splice(pos, 0, ...cmds);
    await saveMapData(projectPath, mapId, mapData);
    return { content: [{ type: "text", text: "Added dialogue." }] };
  }

  if (name === "add_choice") { throw new Error("Tool 'add_choice' is temporarily unavailable (restoration in progress)."); }
  if (name === "set_switch") { throw new Error("Tool 'set_switch' is temporarily unavailable (restoration in progress)."); }
  if (name === "show_picture") { throw new Error("Tool 'show_picture' is temporarily unavailable (restoration in progress)."); }
  if (name === "create_map") { throw new Error("Tool 'create_map' is temporarily unavailable (restoration in progress)."); }
  if (name === "check_assets_integrity") { throw new Error("Tool 'check_assets_integrity' is temporarily unavailable (restoration in progress)."); }

  if (name === "add_loop") {
    const { projectPath, mapId, eventId, pageIndex, insertPosition } = args;
    await validateProjectPath(projectPath);

    const mapData = await loadMapData(projectPath, mapId);
    const list = getEventPageList(mapData, eventId, pageIndex);

    const pos = insertPosition === -1 ? list.length - 1 : insertPosition;

    // Insert Loop (112) and Repeat Above (413)
    // Indent is handled by editor, but we should try to be nice.
    // For now, we just insert with default indent 0, or copy previous?
    // MZ editor recalculates indent on load usually, but let's set 0.
    const loopCmd = { code: 112, indent: 0, parameters: [] };
    const repeatCmd = { code: 413, indent: 0, parameters: [] };

    list.splice(pos, 0, loopCmd, repeatCmd);

    await saveMapData(projectPath, mapId, mapData);

    return {
      content: [{ type: "text", text: "Successfully added Loop block." }],
    };
  }

  if (name === "add_break_loop") {
    const { projectPath, mapId, eventId, pageIndex, insertPosition } = args;
    await validateProjectPath(projectPath);

    const mapData = await loadMapData(projectPath, mapId);
    const list = getEventPageList(mapData, eventId, pageIndex);

    const pos = insertPosition === -1 ? list.length - 1 : insertPosition;
    const cmd = { code: 113, indent: 0, parameters: [] };

    list.splice(pos, 0, cmd);

    await saveMapData(projectPath, mapId, mapData);

    return {
      content: [{ type: "text", text: "Successfully added Break Loop command." }],
    };
  }

  if (name === "add_conditional_branch") {
    const { projectPath, mapId, eventId, pageIndex, insertPosition, condition, includeElse = true } = args;
    await validateProjectPath(projectPath);

    const mapData = await loadMapData(projectPath, mapId);
    const list = getEventPageList(mapData, eventId, pageIndex);

    const pos = insertPosition === -1 ? list.length - 1 : insertPosition;

    // Construct parameters for Code 111
    // [code, dataA, operation, dataB, class]
    const params = [
      condition.code,
      condition.dataA,
      condition.operation,
      condition.dataB,
      condition.class || 0
    ];

    const branchStart = { code: 111, indent: 0, parameters: params };
    const elseCmd = { code: 411, indent: 0, parameters: [] };
    const branchEnd = { code: 412, indent: 0, parameters: [] };

    if (includeElse) {
      list.splice(pos, 0, branchStart, elseCmd, branchEnd);
    } else {
      list.splice(pos, 0, branchStart, branchEnd);
    }

    await saveMapData(projectPath, mapId, mapData);

    return {
      content: [{ type: "text", text: "Successfully added Conditional Branch." }],
    };
  }

  if (name === "delete_event_command") {
    const { projectPath, mapId, eventId, pageIndex, commandIndex } = args;
    await validateProjectPath(projectPath);

    const mapData = await loadMapData(projectPath, mapId);
    const list = getEventPageList(mapData, eventId, pageIndex);

    if (commandIndex < 0 || commandIndex >= list.length) {
      throw new Error(`Command index ${commandIndex} out of bounds (0-${list.length - 1})`);
    }

    list.splice(commandIndex, 1);

    await saveMapData(projectPath, mapId, mapData);

    return {
      content: [{ type: "text", text: `Successfully deleted command at index ${commandIndex}.` }],
    };
  }

  if (name === "add_actor") {
    const { projectPath, name, classId = 1, initialLevel = 1, maxLevel = 99 } = args;
    await validateProjectPath(projectPath);

    const filePath = path.join(projectPath, "data", "Actors.json");
    let actors = [];
    try {
      actors = JSON.parse(await fs.readFile(filePath, "utf-8"));
    } catch (e) {
      // If file doesn't exist or is empty, start with [null]
      actors = [null];
    }

    const newId = actors.length;
    const newActor = {
      id: newId,
      name: name,
      classId: classId,
      level: initialLevel,
      characterName: "",
      characterIndex: 0,
      faceName: "",
      faceIndex: 0,
      traits: [],
      initialLevel: initialLevel,
      maxLevel: maxLevel,
      nickname: "",
      note: "",
      profile: ""
    };

    actors.push(newActor);
    await fs.writeFile(filePath, JSON.stringify(actors, null, 2), "utf-8");

    return {
      content: [{ type: "text", text: `Successfully added actor "${name}" (ID: ${newId}).` }],
    };
  }

  if (name === "add_item") {
    const { projectPath, name, price = 0, consumable = true, scope = 7, occasion = 0 } = args;
    await validateProjectPath(projectPath);

    const filePath = path.join(projectPath, "data", "Items.json");
    let items = [];
    try {
      items = JSON.parse(await fs.readFile(filePath, "utf-8"));
    } catch (e) {
      items = [null];
    }

    const newId = items.length;
    const newItem = {
      id: newId,
      name: name,
      iconIndex: 0,
      description: "",
      price: price,
      consumable: consumable,
      scope: scope,
      occasion: occasion,
      speed: 0,
      successRate: 100,
      repeats: 1,
      tpGain: 0,
      hitType: 0,
      animationId: 0,
      damage: { type: 0, elementId: 0, formula: "0", variance: 20 },
      effects: [],
      note: ""
    };

    items.push(newItem);
    await fs.writeFile(filePath, JSON.stringify(items, null, 2), "utf-8");

    return {
      content: [{ type: "text", text: `Successfully added item "${name}" (ID: ${newId}).` }],
    };
  }

  if (name === "add_skill") {
    const { projectPath, name, mpCost = 0, tpCost = 0, scope = 1, occasion = 1 } = args;
    await validateProjectPath(projectPath);

    const filePath = path.join(projectPath, "data", "Skills.json");
    let skills = [];
    try {
      skills = JSON.parse(await fs.readFile(filePath, "utf-8"));
    } catch (e) {
      skills = [null];
    }

    const newId = skills.length;
    const newSkill = {
      id: newId,
      name: name,
      iconIndex: 0,
      description: "",
      mpCost: mpCost,
      tpCost: tpCost,
      scope: scope,
      occasion: occasion,
      speed: 0,
      successRate: 100,
      repeats: 1,
      tpGain: 0,
      hitType: 1,
      animationId: 0,
      damage: { type: 1, elementId: 0, formula: "0", variance: 20 },
      effects: [],
      note: "",
      message1: "",
      message2: "",
      requiredWtypeId1: 0,
      requiredWtypeId2: 0,
      stypeId: 1
    };

    skills.push(newSkill);
    await fs.writeFile(filePath, JSON.stringify(skills, null, 2), "utf-8");

    return {
      content: [{ type: "text", text: `Successfully added skill "${name}" (ID: ${newId}).` }],
    };

  }

  if (name === "draw_map_tile") {
    const { projectPath, mapId, x, y, layer, tileId } = args;
    await validateProjectPath(projectPath);

    const mapData = await loadMapData(projectPath, mapId);
    const width = mapData.width;
    const height = mapData.height;

    if (x < 0 || x >= width || y < 0 || y >= height) {
      throw new Error(`Coordinates (${x},${y}) out of bounds (W:${width}, H:${height})`);
    }
    if (layer < 0 || layer > 5) {
      throw new Error(`Layer ${layer} out of bounds (0-5)`);
    }

    // Calculate index in flattened array
    // (z * height + y) * width + x
    const index = (layer * height + y) * width + x;

    if (index >= mapData.data.length) {
      throw new Error(`Calculated index ${index} out of bounds`);
    }

    mapData.data[index] = tileId;

    await saveMapData(projectPath, mapId, mapData);

    return {
      content: [{ type: "text", text: `Successfully drew tile ${tileId} at (${x},${y}) on layer ${layer}.` }],
    };

  }

  if (name === "inspect_game_state") {
    const { port = 9222, script } = args;

    const browserUrl = `http://127.0.0.1:${port}`;
    let browser;
    try {
      browser = await puppeteer.connect({
        browserURL: browserUrl,
        defaultViewport: null
      });
    } catch (e) {
      throw new Error(`Failed to connect to game at ${browserUrl}. Is the game running with --remote-debugging-port=${port}?`);
    }

    const pages = await browser.pages();
    const page = pages[0];

    if (!page) {
      browser.disconnect();
      throw new Error("No pages found in the browser.");
    }

    try {
      const result = await page.evaluate((code) => {
        try {
          // eslint-disable-next-line no-eval
          return eval(code);
        } catch (err) {
          return `Error: ${err.message}`;
        }
      }, script);

      browser.disconnect();

      return {
        content: [{ type: "text", text: JSON.stringify(result) }],
      };
    } catch (e) {
      browser.disconnect();
      throw new Error(`Evaluation failed: ${e.message}`);
    }
  }

  if (name === "update_event_command") {
    const { projectPath, mapId, eventId, pageIndex, commandIndex, newCommand } = args;
    await validateProjectPath(projectPath);

    const mapData = await loadMapData(projectPath, mapId);
    const list = getEventPageList(mapData, eventId, pageIndex);

    if (commandIndex < 0 || commandIndex >= list.length) {
      throw new Error(`Command index ${commandIndex} out of bounds (0-${list.length - 1})`);
    }

    // Preserve indent if not specified, though usually it should be provided
    const indent = newCommand.indent !== undefined ? newCommand.indent : list[commandIndex].indent;

    list[commandIndex] = {
      code: newCommand.code,
      indent: indent,
      parameters: newCommand.parameters
    };

    await saveMapData(projectPath, mapId, mapData);

    return {
      content: [{ type: "text", text: `Successfully updated command at index ${commandIndex}.` }],
    };
  }

  if (name === "get_event_page") {
    const { projectPath, mapId, eventId, pageIndex } = args;
    await validateProjectPath(projectPath);

    const mapIdPadded = String(mapId).padStart(3, "0");
    const mapFilePath = path.join(projectPath, "data", `Map${mapIdPadded}.json`);

    let mapData;
    try {
      const mapContent = await fs.readFile(mapFilePath, "utf-8");
      mapData = JSON.parse(mapContent);
    } catch (e) {
      throw new Error(`Failed to read map file: ${e.message}`);
    }

    if (!mapData.events[eventId]) {
      throw new Error(`Event ${eventId} not found in Map ${mapId}`);
    }

    const event = mapData.events[eventId];
    if (!event.pages[pageIndex]) {
      throw new Error(`Page ${pageIndex} not found in Event ${eventId}`);
    }

    const page = event.pages[pageIndex];
    const annotatedList = page.list.map(annotateCommand);

    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(annotatedList, null, 2),
        },
      ],
    };
  }

  throw new Error(`Unknown tool: ${name}`);
} catch (error) {
  return {
    content: [
      {
        type: "text",
        text: `Error: ${error.message}`,
      },
    ],
    isError: true,
  };
}
});

const transport = new StdioServerTransport();
await server.connect(transport);
